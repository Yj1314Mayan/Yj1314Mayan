(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{253:function(t,v,e){"use strict";e.r(v);var _=e(28),a=Object(_.a)({},(function(){var t=this,v=t.$createElement,e=t._self._c||v;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"vue-面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-面试题"}},[t._v("#")]),t._v(" VUE 面试题")]),t._v(" "),e("h3",{attrs:{id:"_1-说一下-vue-的生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-说一下-vue-的生命周期"}},[t._v("#")]),t._v(" 1.说一下 Vue 的生命周期")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("beforeCreate 是 new Vue()之后触发的第一个钩子，在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。")])]),t._v(" "),e("li",[e("p",[t._v("created 在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。可以做一些初始数据的获取，在当前阶段无法与 Dom 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 Dom。")])]),t._v(" "),e("li",[e("p",[t._v("beforeMount 发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 Dom 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated。")])]),t._v(" "),e("li",[e("p",[t._v("mounted 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点，使用$refs 属性对 Dom 进行操作。")])]),t._v(" "),e("li",[e("p",[t._v("beforeUpdate 发生在更新之前，也就是响应式数据发生更新，虚拟 dom 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。")])]),t._v(" "),e("li",[e("p",[t._v("updated 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。")])]),t._v(" "),e("li",[e("p",[t._v("beforeDestroy 发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。")])]),t._v(" "),e("li",[e("p",[t._v("destroyed 发生在实例销毁之后，这个时候只剩下了 dom 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。")])])]),t._v(" "),e("h3",{attrs:{id:"_2-那你能讲一讲-mvvm-吗？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-那你能讲一讲-mvvm-吗？"}},[t._v("#")]),t._v(" 2.那你能讲一讲 MVVM 吗？")]),t._v(" "),e("p",[t._v("MVVM 是 Model-View-ViewModel 缩写，也就是把 MVC 中的 Controller 演变成 ViewModel。Model 层代表数据模型，View 代表 UI 组件，ViewModel 是 View 和 Model 层的桥梁，数据会绑定到 viewModel 层并自动将数据渲染到页面中，视图变化的时候会通知 viewModel 层更新数据。")]),t._v(" "),e("h3",{attrs:{id:"_3-简单说一下-vue2-响应式数据原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-简单说一下-vue2-响应式数据原理"}},[t._v("#")]),t._v(" 3.简单说一下 Vue2 响应式数据原理")]),t._v(" "),e("blockquote",[e("p",[t._v("Vue 在初始化数据时，会使用 Object.defineProperty 重新定义 data 中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的 watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。")])]),t._v(" "),e("li",[e("p",[t._v("实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。")])]),t._v(" "),e("li",[e("p",[t._v("实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。")])]),t._v(" "),e("li",[e("p",[t._v("MVVM 作为一个入口，整合三者，搭起一个桥梁，从而达到了数据更新，视图改变")])])]),t._v(" "),e("h3",{attrs:{id:"_4-再说一下-computed-和-watch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-再说一下-computed-和-watch"}},[t._v("#")]),t._v(" 4.再说一下 Computed 和 Watch")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("Computed 本质是一个具备缓存的 watcher，依赖的属性发生变化就会更新视图。适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。")])]),t._v(" "),e("li",[e("p",[t._v("Watch 没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开 deep：true 选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用 unWatch 手动注销哦。")])])]),t._v(" "),e("h3",{attrs:{id:"_5-说一下-v-if-和-v-show-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-说一下-v-if-和-v-show-的区别"}},[t._v("#")]),t._v(" 5.说一下 v-if 和 v-show 的区别")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("当条件不成立时，v-if 不会渲染 DOM 元素，v-show 操作的是样式(display)，切换当前 DOM 的显示和隐藏。")])]),t._v(" "),e("li",[e("p",[t._v("注意：v-if 会触发生命周期")])])]),t._v(" "),e("h3",{attrs:{id:"_6-说一下-v-model-的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-说一下-v-model-的原理"}},[t._v("#")]),t._v(" 6.说一下 v-model 的原理")]),t._v(" "),e("p",[t._v("v-model 本质就是一个语法糖，可以看成是 value + input 方法的语法糖。可以通过 model 属性的 prop 和 event 属性来进行自定义。原生的 v-model，会根据标签的不同生成不同的事件和属性。")]),t._v(" "),e("h3",{attrs:{id:"_7-组件中-data-为什么是函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-组件中-data-为什么是函数"}},[t._v("#")]),t._v(" 7.组件中 data 为什么是函数")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？")])]),t._v(" "),e("li",[e("p",[t._v("因为组件是用来复用的，JS 里对象是引用关系，这样作用域没有隔离，而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。")])])]),t._v(" "),e("h3",{attrs:{id:"_8-组件间的通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-组件间的通信"}},[t._v("#")]),t._v(" 8.组件间的通信")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("父 -> 子 props children ref provide/inject")])]),t._v(" "),e("li",[e("p",[t._v("子 -> 父 $emit")])]),t._v(" "),e("li",[e("p",[t._v("兄弟 bus")])]),t._v(" "),e("li",[e("p",[t._v("多页面 vuex")])])]),t._v(" "),e("h3",{attrs:{id:"_9-nexttick"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-nexttick"}},[t._v("#")]),t._v(" 9.nextTick()")]),t._v(" "),e("p",[t._v("在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后，立即使用这个回调函数，获取更新后的 DOM。")]),t._v(" "),e("h3",{attrs:{id:"_10-vue-js-的两个核心是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue-js-的两个核心是什么？"}},[t._v("#")]),t._v(" 10.vue.js 的两个核心是什么？")]),t._v(" "),e("p",[t._v("数据驱动和组件化。")]),t._v(" "),e("h3",{attrs:{id:"_11-vue-常用的修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue-常用的修饰符"}},[t._v("#")]),t._v(" 11.vue 常用的修饰符")]),t._v(" "),e("blockquote",[e("p",[t._v("系统修饰符")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v(".ctrl")])]),t._v(" "),e("li",[e("p",[t._v(".alt")])]),t._v(" "),e("li",[e("p",[t._v(".shift")])]),t._v(" "),e("li",[e("p",[t._v(".meta")])])]),t._v(" "),e("blockquote",[e("p",[t._v("鼠标按钮修饰符")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v(".left")])]),t._v(" "),e("li",[e("p",[t._v(".right")])]),t._v(" "),e("li",[e("p",[t._v(".middle")])])]),t._v(" "),e("blockquote",[e("p",[t._v("其他修饰符")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v(".lazy")])]),t._v(" "),e("li",[e("p",[t._v(".number")])]),t._v(" "),e("li",[e("p",[t._v(".trim")])])]),t._v(" "),e("h3",{attrs:{id:"_12-v-on-可以监听多个方法吗？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-v-on-可以监听多个方法吗？"}},[t._v("#")]),t._v(" 12.v-on 可以监听多个方法吗？")]),t._v(" "),e("p",[t._v("可以")]),t._v(" "),e("h3",{attrs:{id:"_13-vue-中-key-值的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-vue-中-key-值的作用"}},[t._v("#")]),t._v(" 13.vue 中 key 值的作用")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("使用 key 来给每个节点做一个唯一标识")])]),t._v(" "),e("li",[e("p",[t._v("key 的作用主要是为了高效的更新虚拟 DOM。另外 vue 中在使用相同标签名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让 vue 可以区分它们，")])]),t._v(" "),e("li",[e("p",[t._v("否则 vue 只会替换其内部属性而不会触发过渡效果。")])])]),t._v(" "),e("h3",{attrs:{id:"_14-说出至少-4-种-vue-当中的指令和它的用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14-说出至少-4-种-vue-当中的指令和它的用法"}},[t._v("#")]),t._v(" 14.说出至少 4 种 vue 当中的指令和它的用法")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("v-if(判断是否隐藏)")])]),t._v(" "),e("li",[e("p",[t._v("v-show(控制展示隐藏)")])]),t._v(" "),e("li",[e("p",[t._v("v-for(把数据遍历出来)")])]),t._v(" "),e("li",[e("p",[t._v("v-bind(绑定属性)")])]),t._v(" "),e("li",[e("p",[t._v("v-model(实现双向绑定)")])]),t._v(" "),e("li",[e("p",[t._v("v-text(输出一段文本)")])]),t._v(" "),e("li",[e("p",[t._v("v-html(输出一段结构)")])])]),t._v(" "),e("h3",{attrs:{id:"_15-怎么定义-vue-router-的动态路由？怎么获取传过来的值？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-怎么定义-vue-router-的动态路由？怎么获取传过来的值？"}},[t._v("#")]),t._v(" 15.怎么定义 vue-router 的动态路由？怎么获取传过来的值？")]),t._v(" "),e("p",[t._v("动态路由的创建，主要是使用 path 属性过程中，使用动态路径参数，以冒号开头，如下：")]),t._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\tpath"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"/details/:id"')]),t._v("\n\n\tname"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Details"')]),t._v("\n\n\tcomponents"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" Details\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("访问 details 目录下的所有文件，如果 details/a，details/b 等，都会映射到 Details 组件上。")]),t._v(" "),e("p",[t._v("当匹配到/details 下的路由时，参数值会被设置到 this.$route.params下，所以通过这个属性可以获取动态参数this.$route.params.id")]),t._v(" "),e("h3",{attrs:{id:"_16-vue-router-有哪几种路由守卫"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-vue-router-有哪几种路由守卫"}},[t._v("#")]),t._v(" 16.vue-router 有哪几种路由守卫?")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("路由守卫为：")])]),t._v(" "),e("li",[e("p",[t._v("全局守卫：beforeEach")])]),t._v(" "),e("li",[e("p",[t._v("后置守卫：afterEach")])]),t._v(" "),e("li",[e("p",[t._v("全局解析守卫：beforeResolve")])]),t._v(" "),e("li",[e("p",[t._v("路由独享守卫：beforeEnter")])])]),t._v(" "),e("h3",{attrs:{id:"_17-route和-router-的区别是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-route和-router-的区别是什么？"}},[t._v("#")]),t._v(" 17.$route和 $router 的区别是什么？")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("$router 为 VueRouter 的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等。")])]),t._v(" "),e("li",[e("p",[t._v("$route 是路由信息对象||跳转的路由对象，每一个路由都会有一个 route 对象，是一个局部对象，包含 path,params,hash,query,fullPath,matched,name 等路由信息参数。")])])]),t._v(" "),e("h3",{attrs:{id:"_18-不用-vuex-会带来什么问题？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_18-不用-vuex-会带来什么问题？"}},[t._v("#")]),t._v(" 18.不用 Vuex 会带来什么问题？")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("可维护性会下降，你要想修改数据，你得维护三个地方")])]),t._v(" "),e("li",[e("p",[t._v("可读性会下降，因为一个组件里的数据，你根本就看不出来是从哪来的")])]),t._v(" "),e("li",[e("p",[t._v("增加耦合，大量的上传派发，会让耦合性大大的增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背。")])])]),t._v(" "),e("h3",{attrs:{id:"_19-vuex-有哪几种属性？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-vuex-有哪几种属性？"}},[t._v("#")]),t._v(" 19.vuex 有哪几种属性？")]),t._v(" "),e("p",[t._v("有五种，分别是 State、 Getter、Mutation 、Action、 Module。")]),t._v(" "),e("h3",{attrs:{id:"_20-vuex-的使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_20-vuex-的使用"}},[t._v("#")]),t._v(" 20.vuex 的使用")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("在 state 中定义数据")])]),t._v(" "),e("li",[e("p",[t._v("Getter 相当于 vue 中的 computed 计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算，Getters 可以用于监听、state 中的值的变化，返回计算后的结果")])]),t._v(" "),e("li",[e("p",[t._v("给 action 注册事件处理函数，当这个函数被触发时候，将状态提交到 mutations 中处理。")])]),t._v(" "),e("li",[e("p",[t._v("mutations 是一个对象里。面的方法 都是同步事务，是更改 state 初始状态的唯一合法方法，具体的用法就是给里面的方法传入参数 state 或额外的参数")])])]),t._v(" "),e("h3",{attrs:{id:"_21-vue-的性能优化？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_21-vue-的性能优化？"}},[t._v("#")]),t._v(" 21.Vue 的性能优化？")]),t._v(" "),e("blockquote",[e("p",[t._v("编码阶段")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher")])]),t._v(" "),e("li",[e("p",[t._v("v-if 和 v-for 不能连用")])]),t._v(" "),e("li",[e("p",[t._v("如果需要使用 v-for 给每项元素绑定事件时使用事件代理")])]),t._v(" "),e("li",[e("p",[t._v("SPA 页面采用 keep-alive 缓存组件")])]),t._v(" "),e("li",[e("p",[t._v("在更多的情况下，使用 v-if 替代 v-show")])]),t._v(" "),e("li",[e("p",[t._v("key 保证唯一")])]),t._v(" "),e("li",[e("p",[t._v("使用路由懒加载、异步组件")])]),t._v(" "),e("li",[e("p",[t._v("防抖、节流")])]),t._v(" "),e("li",[e("p",[t._v("第三方模块按需导入")])]),t._v(" "),e("li",[e("p",[t._v("长列表滚动到可视区域动态加载")])]),t._v(" "),e("li",[e("p",[t._v("图片懒加载")])])]),t._v(" "),e("blockquote",[e("p",[t._v("SEO 优化")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("预渲染")])]),t._v(" "),e("li",[e("p",[t._v("服务端渲染 SSR")])])]),t._v(" "),e("blockquote",[e("p",[t._v("打包优化")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("压缩代码")])]),t._v(" "),e("li",[e("p",[t._v("Tree Shaking/Scope Hoisting")])]),t._v(" "),e("li",[e("p",[t._v("使用 cdn 加载第三方模块")])]),t._v(" "),e("li",[e("p",[t._v("多线程打包 happypack")])]),t._v(" "),e("li",[e("p",[t._v("splitChunks 抽离公共文件")])]),t._v(" "),e("li",[e("p",[t._v("sourceMap 优化")])])]),t._v(" "),e("blockquote",[e("p",[t._v("用户体验")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("骨架屏")])]),t._v(" "),e("li",[e("p",[t._v("PWA")])])]),t._v(" "),e("h3",{attrs:{id:"_22-你的接口请求一般放在哪个生命周期中？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_22-你的接口请求一般放在哪个生命周期中？"}},[t._v("#")]),t._v(" 22.你的接口请求一般放在哪个生命周期中？")]),t._v(" "),e("p",[t._v("接口请求一般放在 mounted 中，但需要注意的是服务端渲染时不支持 mounted，需要放到 created 中。")]),t._v(" "),e("h3",{attrs:{id:"_23-为什么要虚拟-dom？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_23-为什么要虚拟-dom？"}},[t._v("#")]),t._v(" 23.为什么要虚拟 DOM？")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("虚拟 DOM 就是为了解决这个浏览器性能问题而被设计出来的，如果一次操作中有 10 次更新 DOM 的操作，虚拟 DOM 不会立即操作 DOM，而是将这 10 次更新的 diff 内容保存在本地的一个 js 对象中，最终将这个 js 对象一次性 attach 到 DOM 树上，通知浏览器去执行绘制工作，这样可以避免大量的无谓的计算量。")])]),t._v(" "),e("li",[e("p",[t._v("在实际代码中，会对新旧两棵树进行一个深度的遍历，每个节点都会有一个标记。每遍历到一个节点，就把该节点和新的树进行对比，如果有差异就记录到一个对象中。然后映射到真是 DOM。")])])]),t._v(" "),e("h3",{attrs:{id:"_24-虚拟-dom-与真实-dom-的区别？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_24-虚拟-dom-与真实-dom-的区别？"}},[t._v("#")]),t._v(" 24.虚拟 DOM 与真实 DOM 的区别？")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("虚拟 DOM 不会进行重排与重绘操作；")])]),t._v(" "),e("li",[e("p",[t._v("虚拟 DOM 进行频繁修改，然后一次性比较并修改真实 DOM 中需要修改的部分，最后进行重排和重绘，减少过多 DOM 节点重排和重绘损耗。")])]),t._v(" "),e("li",[e("p",[t._v("虚拟 DOM 有效降低大面积（真实 DOM 节点）的重排和重绘，因为最终与真实 DOM 比较差异，可以局部渲染。")])])]),t._v(" "),e("h3",{attrs:{id:"_25-vue-中的-diff-算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_25-vue-中的-diff-算法"}},[t._v("#")]),t._v(" 25.Vue 中的 diff 算法")]),t._v(" "),e("p",[t._v("概括起来就是对操作前后的 dom 树同一层的节点进行对比，一层一层对比，然后再插入真实的 dom 中，重新渲染，注意 diff 算法是需要使用 key 来给每个节点做一个唯一标识，Diff 算法就可以正确的识别此节点，找到正确的位置区插入新的节点。")]),t._v(" "),e("h3",{attrs:{id:"_26-v-text-和-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_26-v-text-和-的区别"}},[t._v("#")]),t._v(" 26.v-text 和{{}}的区别")]),t._v(" "),e("ul",[e("li",[e("p",[t._v(t._s(t.text)+" // 将数据解析成为纯文本，不能显示输出 HTML")])]),t._v(" "),e("li",[e("p",[t._v('v-text="text"：将数据解析为纯文本，不能输出真正的 html，与花括号的区别是在页面加载时不显示{{}}')])])]),t._v(" "),e("h3",{attrs:{id:"_26-hash-和-history-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_26-hash-和-history-的区别"}},[t._v("#")]),t._v(" 26.hash 和 history 的区别")]),t._v(" "),e("blockquote",[e("p",[t._v("hash ——即地址栏 URL 中的#符号（此 hsah 不是密码学里的散列运算）。          比如这个 URL：http://www.abc.com/#/hello, hash 的值为#/hello。它的特点在于：hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。")])]),t._v(" "),e("blockquote",[e("p",[t._v("history ——利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法")])]),t._v(" "),e("ul",[e("li",[e("p",[t._v("使用 pushState()跳转时会在历史记录里面添加一条历史记录，即 go(-1)返回的时候是返回到上一条记录")])]),t._v(" "),e("li",[e("p",[t._v("使用 replaceState()跳转时不会往历史记录里面添加记录，即 go(-1)返回的时候是返回到上上一条记录")])])])])}),[],!1,null,null,null);v.default=a.exports}}]);