(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{253:function(_,t,v){"use strict";v.r(t);var e=v(28),s=Object(e.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"es6-面试题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#es6-面试题"}},[_._v("#")]),_._v(" ES6 面试题")]),_._v(" "),v("h3",{attrs:{id:"_1-es5-和-es6-的区别，说一下你所知道的-es6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-es5-和-es6-的区别，说一下你所知道的-es6"}},[_._v("#")]),_._v(" 1.es5 和 es6 的区别，说一下你所知道的 es6")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("ECMAScript5，即 ES5，是 ECMAScript 的第五次修订，于 2009 年完成标准化")])]),_._v(" "),v("li",[v("p",[_._v("ECMAScript6，即 ES6，是 ECMAScript 的第六次修订，于 2015 年完成，也称 ES2015")])]),_._v(" "),v("li",[v("p",[_._v("ES6 是继 ES5 之后的一次改进，相对于 ES5 更加简洁，提高了开发效率")])])]),_._v(" "),v("h3",{attrs:{id:"_2-es6-新增的一些特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-es6-新增的一些特性"}},[_._v("#")]),_._v(" 2.ES6 新增的一些特性")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("let 声明变量和 const 声明常量，两个都有块级作用域")]),_._v(" "),v("blockquote",[v("p",[_._v("ES5 中是没有块级作用域的，并且 var 有变量提升，在 let 中，使用的变量一定要进行声明")])])]),_._v(" "),v("li",[v("p",[_._v("箭头函数")]),_._v(" "),v("blockquote",[v("p",[_._v("ES6 中的函数定义不再使用关键字 function()，而是利用了()=>来进行定义")])])]),_._v(" "),v("li",[v("p",[_._v("模板字符串")]),_._v(" "),v("blockquote",[v("p",[_._v("模板字符串是增强版的字符串，用反引号（`）标识，可以当作普通字符串使用，也可以用来定义多行字符串")])])]),_._v(" "),v("li",[v("p",[_._v("解构赋值")]),_._v(" "),v("blockquote",[v("p",[_._v("ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值")])])]),_._v(" "),v("li",[v("p",[_._v("for of 循环")]),_._v(" "),v("blockquote",[v("p",[_._v("for...of 循环可以遍历数组、Set 和 Map 结构、某些类似数组的对象、对象，以及字符串")])])]),_._v(" "),v("li",[v("p",[_._v("import、export 导入导出")]),_._v(" "),v("blockquote",[v("p",[_._v("ES6 标准中，Js 原生支持模块(module)。将 JS 代码分割成不同功能的小块进行模块化，将不同功能的代码分别写在不同文件中，各模块只需导出公共接口部分，然后通过模块的导入的方式可以在其他地方使用")])])]),_._v(" "),v("li",[v("p",[_._v("set 数据结构")]),_._v(" "),v("blockquote",[v("p",[_._v("Set 数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数")])])]),_._v(" "),v("li",[v("p",[_._v("... 展开运算符")]),_._v(" "),v("blockquote",[v("p",[_._v("可以将数组或对象里面的值展开；还可以将多个值收集为一个变量")])])]),_._v(" "),v("li",[v("p",[_._v("修饰器 @")]),_._v(" "),v("blockquote",[v("p",[_._v("decorator 是一个函数，用来修改类甚至于是方法的行为。修饰器本质就是编译时执行的函数")])])]),_._v(" "),v("li",[v("p",[_._v("class 类的继承")]),_._v(" "),v("blockquote",[v("p",[_._v("ES6 中不再像 ES5 一样使用原型链实现继承，而是引入 Class 这个概念")])])]),_._v(" "),v("li",[v("p",[_._v("async、await")]),_._v(" "),v("blockquote",[v("p",[_._v("使用 async/await, 搭配 promise,可以通过编写形似同步的代码来处理异步流程, 提高代码的简洁性和可读性\nasync 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成")])])]),_._v(" "),v("li",[v("p",[_._v("promise")]),_._v(" "),v("blockquote",[v("p",[_._v("Promise 是异步编程的一种解决方案，比传统的解决方案（回调函数和事件）更合理、强大")])])]),_._v(" "),v("li",[v("p",[_._v("Symbol")]),_._v(" "),v("blockquote",[v("p",[_._v("Symbol 是一种基本类型。Symbol 通过调用 symbol 函数产生，它接收一个可选的名字参数，该函数返回的 symbol 是唯一的")])])]),_._v(" "),v("li",[v("p",[_._v("Proxy 代理")]),_._v(" "),v("blockquote",[v("p",[_._v("使用代理（Proxy）监听对象的操作，然后可以做一些相应事情")])])])]),_._v(" "),v("h3",{attrs:{id:"_3-var、let、const-之间的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-var、let、const-之间的区别"}},[_._v("#")]),_._v(" 3.var、let、const 之间的区别")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("var 声明变量可以重复声明，而 let 不可以重复声明")])]),_._v(" "),v("li",[v("p",[_._v("var 是不受限于块级的，而 let 是受限于块级")])]),_._v(" "),v("li",[v("p",[_._v("var 会与 window 相映射（会挂一个属性），而 let 不与 window 相映射")])]),_._v(" "),v("li",[v("p",[_._v("var 可以在声明的上面访问变量，而 let 有暂存死区，在声明的上面访问变量会报错")])]),_._v(" "),v("li",[v("p",[_._v("const 声明之后必须赋值，否则会报错")])]),_._v(" "),v("li",[v("p",[_._v("const 定义不可变的量，改变了就会报错")])]),_._v(" "),v("li",[v("p",[_._v("const 和 let 一样不会与 window 相映射、支持块级作用域、在声明的上面访问变量会报错")])])]),_._v(" "),v("h3",{attrs:{id:"_4-使用箭头函数应注意什么？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-使用箭头函数应注意什么？"}},[_._v("#")]),_._v(" 4.使用箭头函数应注意什么？")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("用了箭头函数，this 就不是指向 window，而是父级（指向是可变的）")])]),_._v(" "),v("li",[v("p",[_._v("不能够使用 arguments 对象")])]),_._v(" "),v("li",[v("p",[_._v("不能用作构造函数，这就是说不能够使用 new 命令，否则会抛出一个错误")])]),_._v(" "),v("li",[v("p",[_._v("不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数")])])]),_._v(" "),v("h3",{attrs:{id:"_5-promise-构造函数是同步执行还是异步执行，那么-then-方法呢？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-promise-构造函数是同步执行还是异步执行，那么-then-方法呢？"}},[_._v("#")]),_._v(" 5.Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？")]),_._v(" "),v("ul",[v("li",[_._v("promise 构造函数是同步执行的，then 方法是异步执行的")])]),_._v(" "),v("h3",{attrs:{id:"_6-promise-有几种状态，什么时候会进入-catch？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-promise-有几种状态，什么时候会进入-catch？"}},[_._v("#")]),_._v(" 6.promise 有几种状态，什么时候会进入 catch？")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("三个状态：pending、fulfilled、reject")])]),_._v(" "),v("li",[v("p",[_._v("两个过程：padding -> fulfilled、padding -> rejected")])]),_._v(" "),v("li",[v("p",[_._v("当 pending 为 rejectd 时，会进入 catch")])])]),_._v(" "),v("h3",{attrs:{id:"_7-promise-有几种状态，什么时候会进入-catch？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-promise-有几种状态，什么时候会进入-catch？"}},[_._v("#")]),_._v(" 7.promise 有几种状态，什么时候会进入 catch？")]),_._v(" "),v("p",[_._v("ES6 的 class 可以看作是一个语法糖，它的绝大部分功能 ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法")])])}),[],!1,null,null,null);t.default=s.exports}}]);