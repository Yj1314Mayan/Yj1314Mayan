(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{256:function(v,t,e){"use strict";e.r(t);var _=e(28),a=Object(_.a)({},(function(){var v=this,t=v.$createElement,e=v._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h2",{attrs:{id:"vue-面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-面试题"}},[v._v("#")]),v._v(" VUE 面试题")]),v._v(" "),e("h3",{attrs:{id:"_1-说一下-vue-的生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-说一下-vue-的生命周期"}},[v._v("#")]),v._v(" 1.说一下 Vue 的生命周期")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("beforeCreate 是 new Vue()之后触发的第一个钩子，在当前阶段 data、methods、computed 以及 watch 上的数据和方法都不能被访问。")])]),v._v(" "),e("li",[e("p",[v._v("created 在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发 updated 函数。可以做一些初始数据的获取，在当前阶段无法与 Dom 进行交互，如果非要想，可以通过 vm.$nextTick 来访问 Dom。")])]),v._v(" "),e("li",[e("p",[v._v("beforeMount 发生在挂载之前，在这之前 template 模板已导入渲染函数编译。而当前阶段虚拟 Dom 已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发 updated。")])]),v._v(" "),e("li",[e("p",[v._v("mounted 在挂载完成后发生，在当前阶段，真实的 Dom 挂载完毕，数据完成双向绑定，可以访问到 Dom 节点，使用$refs 属性对 Dom 进行操作。")])]),v._v(" "),e("li",[e("p",[v._v("beforeUpdate 发生在更新之前，也就是响应式数据发生更新，虚拟 dom 重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。")])]),v._v(" "),e("li",[e("p",[v._v("updated 发生在更新完成之后，当前阶段组件 Dom 已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。")])]),v._v(" "),e("li",[e("p",[v._v("beforeDestroy 发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。")])]),v._v(" "),e("li",[e("p",[v._v("destroyed 发生在实例销毁之后，这个时候只剩下了 dom 空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。")])])]),v._v(" "),e("h3",{attrs:{id:"_2-那你能讲一讲-mvvm-吗？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-那你能讲一讲-mvvm-吗？"}},[v._v("#")]),v._v(" 2.那你能讲一讲 MVVM 吗？")]),v._v(" "),e("p",[v._v("MVVM 是 Model-View-ViewModel 缩写，也就是把 MVC 中的 Controller 演变成 ViewModel。Model 层代表数据模型，View 代表 UI 组件，ViewModel 是 View 和 Model 层的桥梁，数据会绑定到 viewModel 层并自动将数据渲染到页面中，视图变化的时候会通知 viewModel 层更新数据。")]),v._v(" "),e("h3",{attrs:{id:"_3-简单说一下-vue2-响应式数据原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-简单说一下-vue2-响应式数据原理"}},[v._v("#")]),v._v(" 3.简单说一下 Vue2 响应式数据原理")]),v._v(" "),e("blockquote",[e("p",[v._v("Vue 在初始化数据时，会使用 Object.defineProperty 重新定义 data 中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的 watcher)如果属性发生变化会通知相关依赖进行更新操作(发布订阅)")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("实现一个监听器 Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。")])]),v._v(" "),e("li",[e("p",[v._v("实现一个订阅者 Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。")])]),v._v(" "),e("li",[e("p",[v._v("实现一个解析器 Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。")])]),v._v(" "),e("li",[e("p",[v._v("MVVM 作为一个入口，整合三者，搭起一个桥梁，从而达到了数据更新，视图改变")])])]),v._v(" "),e("h3",{attrs:{id:"_4-再说一下-computed-和-watch"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-再说一下-computed-和-watch"}},[v._v("#")]),v._v(" 4.再说一下 Computed 和 Watch")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("Computed 本质是一个具备缓存的 watcher，依赖的属性发生变化就会更新视图。适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。")])]),v._v(" "),e("li",[e("p",[v._v("Watch 没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开 deep：true 选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用字符串形式监听，如果没有写到组件中，不要忘记使用 unWatch 手动注销哦。")])])]),v._v(" "),e("h3",{attrs:{id:"_5-说一下-v-if-和-v-show-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-说一下-v-if-和-v-show-的区别"}},[v._v("#")]),v._v(" 5.说一下 v-if 和 v-show 的区别")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("当条件不成立时，v-if 不会渲染 DOM 元素，v-show 操作的是样式(display)，切换当前 DOM 的显示和隐藏。")])]),v._v(" "),e("li",[e("p",[v._v("注意：v-if 会触发生命周期")])])]),v._v(" "),e("h3",{attrs:{id:"_6-说一下-v-model-的原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-说一下-v-model-的原理"}},[v._v("#")]),v._v(" 6.说一下 v-model 的原理")]),v._v(" "),e("p",[v._v("v-model 本质就是一个语法糖，可以看成是 value + input 方法的语法糖。可以通过 model 属性的 prop 和 event 属性来进行自定义。原生的 v-model，会根据标签的不同生成不同的事件和属性。")]),v._v(" "),e("h3",{attrs:{id:"_7-组件中-data-为什么是函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-组件中-data-为什么是函数"}},[v._v("#")]),v._v(" 7.组件中 data 为什么是函数")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？")])]),v._v(" "),e("li",[e("p",[v._v("因为组件是用来复用的，JS 里对象是引用关系，这样作用域没有隔离，而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题。")])])]),v._v(" "),e("h3",{attrs:{id:"_8-组件间的通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-组件间的通信"}},[v._v("#")]),v._v(" 8.组件间的通信")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("父 -> 子 props children ref provide/inject")])]),v._v(" "),e("li",[e("p",[v._v("子 -> 父 $emit")])]),v._v(" "),e("li",[e("p",[v._v("兄弟 bus")])]),v._v(" "),e("li",[e("p",[v._v("多页面 vuex")])])]),v._v(" "),e("h3",{attrs:{id:"_9-nexttick"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-nexttick"}},[v._v("#")]),v._v(" 9.nextTick()")]),v._v(" "),e("p",[v._v("在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后，立即使用这个回调函数，获取更新后的 DOM。")]),v._v(" "),e("h3",{attrs:{id:"_10-vue-js-的两个核心是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue-js-的两个核心是什么？"}},[v._v("#")]),v._v(" 10.vue.js 的两个核心是什么？")]),v._v(" "),e("p",[v._v("数据驱动和组件化。")]),v._v(" "),e("h3",{attrs:{id:"_11-vue-常用的修饰符"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue-常用的修饰符"}},[v._v("#")]),v._v(" 11.vue 常用的修饰符")]),v._v(" "),e("blockquote",[e("p",[v._v("系统修饰符")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v(".ctrl")])]),v._v(" "),e("li",[e("p",[v._v(".alt")])]),v._v(" "),e("li",[e("p",[v._v(".shift")])]),v._v(" "),e("li",[e("p",[v._v(".meta")])])]),v._v(" "),e("blockquote",[e("p",[v._v("鼠标按钮修饰符")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v(".left")])]),v._v(" "),e("li",[e("p",[v._v(".right")])]),v._v(" "),e("li",[e("p",[v._v(".middle")])])]),v._v(" "),e("blockquote",[e("p",[v._v("其他修饰符")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v(".lazy")])]),v._v(" "),e("li",[e("p",[v._v(".number")])]),v._v(" "),e("li",[e("p",[v._v(".trim")])])]),v._v(" "),e("h3",{attrs:{id:"_12-v-on-可以监听多个方法吗？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-v-on-可以监听多个方法吗？"}},[v._v("#")]),v._v(" 12.v-on 可以监听多个方法吗？")]),v._v(" "),e("p",[v._v("可以")]),v._v(" "),e("h3",{attrs:{id:"_13-vue-中-key-值的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-vue-中-key-值的作用"}},[v._v("#")]),v._v(" 13.vue 中 key 值的作用")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("使用 key 来给每个节点做一个唯一标识")])]),v._v(" "),e("li",[e("p",[v._v("key 的作用主要是为了高效的更新虚拟 DOM。另外 vue 中在使用相同标签名元素的过渡切换时，也会使用到 key 属性，其目的也是为了让 vue 可以区分它们，")])]),v._v(" "),e("li",[e("p",[v._v("否则 vue 只会替换其内部属性而不会触发过渡效果。")])])]),v._v(" "),e("h3",{attrs:{id:"_14-说出至少-4-种-vue-当中的指令和它的用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14-说出至少-4-种-vue-当中的指令和它的用法"}},[v._v("#")]),v._v(" 14.说出至少 4 种 vue 当中的指令和它的用法")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("v-if(判断是否隐藏)")])]),v._v(" "),e("li",[e("p",[v._v("v-show(控制展示隐藏)")])]),v._v(" "),e("li",[e("p",[v._v("v-for(把数据遍历出来)")])]),v._v(" "),e("li",[e("p",[v._v("v-bind(绑定属性)")])]),v._v(" "),e("li",[e("p",[v._v("v-model(实现双向绑定)")])]),v._v(" "),e("li",[e("p",[v._v("v-text(输出一段文本)")])]),v._v(" "),e("li",[e("p",[v._v("v-html(输出一段结构)")])])]),v._v(" "),e("h3",{attrs:{id:"_15-怎么定义-vue-router-的动态路由？怎么获取传过来的值？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-怎么定义-vue-router-的动态路由？怎么获取传过来的值？"}},[v._v("#")]),v._v(" 15.怎么定义 vue-router 的动态路由？怎么获取传过来的值？")]),v._v(" "),e("p",[v._v("动态路由的创建，主要是使用 path 属性过程中，使用动态路径参数，以冒号开头，如下：")]),v._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n\tpath"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[v._v("'/details/:id'")]),v._v("\n\n\tname"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[v._v("'Details'")]),v._v("\n\n\tcomponents"),e("span",{pre:!0,attrs:{class:"token operator"}},[v._v(":")]),v._v(" Details\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])])]),e("p",[v._v("访问 details 目录下的所有文件，如果 details/a，details/b 等，都会映射到 Details 组件上。")]),v._v(" "),e("p",[v._v("当匹配到/details 下的路由时，参数值会被设置到 this.$route.params下，所以通过这个属性可以获取动态参数this.$route.params.id")]),v._v(" "),e("h3",{attrs:{id:"_16-vue-router-有哪几种路由守卫"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-vue-router-有哪几种路由守卫"}},[v._v("#")]),v._v(" 16.vue-router 有哪几种路由守卫?")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("路由守卫为：")])]),v._v(" "),e("li",[e("p",[v._v("全局守卫：beforeEach")])]),v._v(" "),e("li",[e("p",[v._v("后置守卫：afterEach")])]),v._v(" "),e("li",[e("p",[v._v("全局解析守卫：beforeResolve")])]),v._v(" "),e("li",[e("p",[v._v("路由独享守卫：beforeEnter")])])]),v._v(" "),e("h3",{attrs:{id:"_17-route和-router-的区别是什么？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-route和-router-的区别是什么？"}},[v._v("#")]),v._v(" 17.$route和 $router 的区别是什么？")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("$router 为 VueRouter 的实例，是一个全局路由对象，包含了路由跳转的方法、钩子函数等。")])]),v._v(" "),e("li",[e("p",[v._v("$route 是路由信息对象||跳转的路由对象，每一个路由都会有一个 route 对象，是一个局部对象，包含 path,params,hash,query,fullPath,matched,name 等路由信息参数。")])])]),v._v(" "),e("h3",{attrs:{id:"_18-不用-vuex-会带来什么问题？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_18-不用-vuex-会带来什么问题？"}},[v._v("#")]),v._v(" 18.不用 Vuex 会带来什么问题？")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("可维护性会下降，你要想修改数据，你得维护三个地方")])]),v._v(" "),e("li",[e("p",[v._v("可读性会下降，因为一个组件里的数据，你根本就看不出来是从哪来的")])]),v._v(" "),e("li",[e("p",[v._v("增加耦合，大量的上传派发，会让耦合性大大的增加，本来 Vue 用 Component 就是为了减少耦合，现在这么用，和组件化的初衷相背。")])])]),v._v(" "),e("h3",{attrs:{id:"_19-vuex-有哪几种属性？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-vuex-有哪几种属性？"}},[v._v("#")]),v._v(" 19.vuex 有哪几种属性？")]),v._v(" "),e("p",[v._v("有五种，分别是 State、 Getter、Mutation 、Action、 Module。")]),v._v(" "),e("h3",{attrs:{id:"_20-vuex-的使用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_20-vuex-的使用"}},[v._v("#")]),v._v(" 20.vuex 的使用")]),v._v(" "),e("ul",[e("li",[e("p",[v._v("在 state 中定义数据")])]),v._v(" "),e("li",[e("p",[v._v("Getter 相当于 vue 中的 computed 计算属性，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算，Getters 可以用于监听、state 中的值的变化，返回计算后的结果")])]),v._v(" "),e("li",[e("p",[v._v("给 action 注册事件处理函数，当这个函数被触发时候，将状态提交到 mutations 中处理。")])]),v._v(" "),e("li",[e("p",[v._v("mutations 是一个对象里。面的方法 都是同步事务，是更改 state 初始状态的唯一合法方法，具体的用法就是给里面的方法传入参数 state 或额外的参数")])])]),v._v(" "),e("h3",{attrs:{id:"_21-vue-的性能优化？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_21-vue-的性能优化？"}},[v._v("#")]),v._v(" 21.Vue 的性能优化？")]),v._v(" "),e("blockquote",[e("p",[v._v("编码阶段")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("尽量减少 data 中的数据，data 中的数据都会增加 getter 和 setter，会收集对应的 watcher")])]),v._v(" "),e("li",[e("p",[v._v("v-if 和 v-for 不能连用")])]),v._v(" "),e("li",[e("p",[v._v("如果需要使用 v-for 给每项元素绑定事件时使用事件代理")])]),v._v(" "),e("li",[e("p",[v._v("SPA 页面采用 keep-alive 缓存组件")])]),v._v(" "),e("li",[e("p",[v._v("在更多的情况下，使用 v-if 替代 v-show")])]),v._v(" "),e("li",[e("p",[v._v("key 保证唯一")])]),v._v(" "),e("li",[e("p",[v._v("使用路由懒加载、异步组件")])]),v._v(" "),e("li",[e("p",[v._v("防抖、节流")])]),v._v(" "),e("li",[e("p",[v._v("第三方模块按需导入")])]),v._v(" "),e("li",[e("p",[v._v("长列表滚动到可视区域动态加载")])]),v._v(" "),e("li",[e("p",[v._v("图片懒加载")])])]),v._v(" "),e("blockquote",[e("p",[v._v("SEO 优化")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("预渲染")])]),v._v(" "),e("li",[e("p",[v._v("服务端渲染 SSR")])])]),v._v(" "),e("blockquote",[e("p",[v._v("打包优化")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("压缩代码")])]),v._v(" "),e("li",[e("p",[v._v("Tree Shaking/Scope Hoisting")])]),v._v(" "),e("li",[e("p",[v._v("使用 cdn 加载第三方模块")])]),v._v(" "),e("li",[e("p",[v._v("多线程打包 happypack")])]),v._v(" "),e("li",[e("p",[v._v("splitChunks 抽离公共文件")])]),v._v(" "),e("li",[e("p",[v._v("sourceMap 优化")])])]),v._v(" "),e("blockquote",[e("p",[v._v("用户体验")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("骨架屏")])]),v._v(" "),e("li",[e("p",[v._v("PWA")])])]),v._v(" "),e("h3",{attrs:{id:"_22-你的接口请求一般放在哪个生命周期中？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_22-你的接口请求一般放在哪个生命周期中？"}},[v._v("#")]),v._v(" 22.你的接口请求一般放在哪个生命周期中？")]),v._v(" "),e("p",[v._v("接口请求一般放在 mounted 中，但需要注意的是服务端渲染时不支持 mounted，需要放到 created 中。")])])}),[],!1,null,null,null);t.default=a.exports}}]);